Index: generate_results.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import find_data as fd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.spatial import distance\nimport pandas as pd\nfrom param import *\nfrom numba import njit\n\n\ndef in_patch(position, patch):\n    \"\"\"\n    returns True if position = [x,y] is inside the patch\n    uses general parameter radial_tolerance: the worm is still considered inside the patch when its center is sticking out by that distance or less\n    \"\"\"\n    center = [patch[0], patch[1]]\n    radius = patch_radius\n    distance_from_center = np.sqrt((position[0] - center[0]) ** 2 + (position[1] - center[1]) ** 2)\n    return distance_from_center < radius + radial_tolerance\n\n\n#@njit(parallel=True)\ndef patch_visits_single_traj(list_x, list_y, first_pos, patch_centers):\n    \"\"\"\n    Takes a trajectory under the format: [x0 x1 ... xN] [y0 y1 ... yN] and a list of patch centers\n    For now, uses the unique patch_radius defined as a global parameter.\n    Returns a list [[d0,d1,...], [d0,d1,...],...] with one list per patch\n    each sublist contains the durations of visits to each patch\n    so len(output[0]) is the number of visits to the first patch\n    \"\"\"\n\n    # Variables for the loop and the output\n    is_in_patch = np.zeros(\n        len(patch_centers))  # Bool list to store where the worm is currently (1 where it currently is)\n\n    # In list_of_durations, we will have one list per patch, containing the duration of successive visits to that patch\n    # Zero means \"the worm was not in that patch in the previous timestep\"\n    # As soon as the worm enters the patch, this zero starts being incremented\n    # As soon as the worm leaves the patch, a new zero is added to this patch's list\n    # These 0 are added for computational ease and will be removed in the end\n    list_of_durations = [list(i) for i in\n                         np.zeros((len(patch_centers), 1), dtype='int')]  # List with the right format [[0],[0],...,[0]]\n\n    # Order in which the patches were visited (should have as many elements as list_of_durations)\n    # In order_of_visits: if last element is -1, worm was out in the previous timestep\n    # otherwise, it means it was already in that patch in the previous timestep, so it's not a new visit\n    order_of_visits = [-1]\n\n    # List of transit durations, to compute average transit time between patches\n    list_of_transit_durations = [0]\n\n    # This is the list of durations we will use to test the Marginal Value Theorem\n    # In order to do so, if the worm visits the same patch multiple times in a row, we count that as one visit\n    # The encoding is the same as list_of_durations, 0 = worm was not in that patch in its previous visit\n    adjusted_list_of_durations = [list(i) for i in\n                                  np.zeros((len(patch_centers), 1),\n                                           dtype='int')]  # List with the right format [[0],[0],...,[0]]\n\n    patch_where_it_is = -1  # initializing variable with index of patch where the worm currently is\n    # We go through the whole trajectory\n    for time in range(len(list_x)):\n        patch_where_it_was = patch_where_it_is  # index of the patch where it is\n        patch_where_it_is = -1  # resetting the variable of current patch position\n        for i_patch in range(len(patch_centers)):  # for every patch\n            is_in_patch[i_patch] = in_patch([list_x[time], list_y[time]],\n                                            patch_centers[i_patch])  # check if the worm is in it\n            if is_in_patch[i_patch]:  # if it's in it, keep that in mind\n                patch_where_it_is = i_patch\n\n        # Worm currently out\n        if patch_where_it_is == -1:\n            list_of_transit_durations[-1] += 1  # add 1 to current transit duration\n            if patch_where_it_was != patch_where_it_is:  # Worm just exited a patch\n                list_of_durations[patch_where_it_was].append(0)  # Add a zero because previous visit was interrupted\n                order_of_visits.append(-1)\n\n        # Worm currently inside, no matter whether it just entered or stayed inside\n        if patch_where_it_is != -1:\n            if order_of_visits[-1] == -1:  # if the worm just entered the patch\n                order_of_visits[-1] = patch_where_it_is  # add this patch to the visit order\n                list_of_transit_durations.append(0)  # start a new transit\n                if len(order_of_visits) > 2 and order_of_visits[-1] != order_of_visits[\n                    -2]:  # if it's not the same patch as the previous visit\n                    adjusted_list_of_durations[order_of_visits[-2]].append(0)  # start a new visit in the previous patch\n            list_of_durations[patch_where_it_is][-1] += 1  # add one to the last element of the current patch sublist\n            adjusted_list_of_durations[patch_where_it_is][-1] += 1  # same for adjusted\n\n    duration_sum = 0  # this is to compute the avg duration of visits\n    nb_of_visits = 0\n    adjusted_duration_sum = 0\n    adjusted_nb_of_visits = 0\n    list_of_visited_patches = []\n    furthest_patch_distance = 0\n\n    # Run through each patch to compute global variables\n    for i_patch in range(len(list_of_durations)):\n        # Remove the zeros because they're just here for the duration algorithm\n        list_of_durations[i_patch] = [nonzero for nonzero in list_of_durations[i_patch] if nonzero != 0]\n        adjusted_list_of_durations[i_patch] = [nonzero for nonzero in adjusted_list_of_durations[i_patch] if nonzero != 0]\n\n        # Update list of visited patches and the furthest patch visited\n        if len(list_of_durations[i_patch]) > 0:  # if the patch was visited at least once in this trajectory\n            patch_distance_to_center = distance.euclidean(first_pos, patch_centers[i_patch])\n            furthest_patch_distance = max(patch_distance_to_center, furthest_patch_distance)\n            list_of_visited_patches.append(i_patch)\n\n        # Visits info for average visit duration\n        duration_sum += sum(list_of_durations[i_patch])\n        nb_of_visits += len(list_of_durations[i_patch])\n\n        # Same but adjusted for multiple consecutive visits to same patch\n        adjusted_duration_sum += sum(adjusted_list_of_durations[i_patch])\n        adjusted_nb_of_visits += len(adjusted_list_of_durations[i_patch])\n\n    total_transit_time = np.sum(list_of_transit_durations)\n\n    return list_of_durations, order_of_visits, duration_sum, nb_of_visits, list_of_visited_patches, furthest_patch_distance, total_transit_time, adjusted_list_of_durations, adjusted_duration_sum, adjusted_nb_of_visits\n\n\ndef patch_visits_multiple_traj(data):\n    \"\"\"\n    Takes our data table and returns a series of analysis regarding patch visits, one line per worm\n    \"\"\"\n    worm_list = np.unique(data[\"id_conservative\"])\n    nb_of_worms = len(worm_list)\n\n    results_table = pd.DataFrame()\n    results_table[\"folder\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"condition\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"worm_id\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"total_time\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"raw_visits\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"order_of_visits\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"duration_sum\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"nb_of_visits\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"list_of_visited_patches\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"furthest_patch_distance\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"total_transit_time\"] = [-1 for i in range(nb_of_worms)]\n    results_table[\"adjusted_raw_visits\"] = [-1 for i in range(nb_of_worms)]  # consecutive visits to same patch= 1 visit\n    results_table[\"adjusted_duration_sum\"] = [-1 for i in range(nb_of_worms)]  # THIS SHOULD BE THE SAME AS DURATION SUM\n    results_table[\"adjusted_nb_of_visits\"] = [-1 for i in range(nb_of_worms)]\n\n    old_folder = \"caca\"\n    for i_worm in range(nb_of_worms):\n        # Handmade progress bar\n        print(i_worm, \"/\", nb_of_worms)\n\n        # Data from the dataframe\n        current_worm = worm_list[i_worm]\n        current_data = data[data[\"id_conservative\"] == current_worm]\n        current_list_x = current_data[\"x\"]\n        current_list_y = current_data[\"y\"]\n        current_folder = list(current_data[\"folder\"])[0]\n\n        # First recorded position of each plate is first position of the first worm of the plate\n        if current_folder != old_folder:\n            first_pos = [current_data[\"x\"][0], current_data[\"y\"][0]]\n        old_folder = current_folder\n\n        # Getting to the metadata through the folder name in the data\n        current_metadata = fd.folder_to_metadata(current_folder)\n        list_of_densities = current_metadata[\"patch_densities\"]\n\n        # Computing the visit durations\n        raw_durations, order_of_visits, duration_sum, nb_of_visits, list_of_visited_patches, furthest_patch_distance, \\\n            total_transit_time, adjusted_raw_visits, adjusted_duration_sum, adjusted_nb_of_visits = patch_visits_single_traj(\n                list(current_list_x), list(current_list_y), first_pos, current_metadata[\"patch_centers\"])\n\n        # Fill up results table\n        results_table.loc[i_worm, \"folder\"] = current_folder\n        results_table.loc[i_worm, \"condition\"] = current_metadata[\"condition\"][0]\n        results_table.loc[i_worm, \"worm_id\"] = current_worm\n        results_table.loc[i_worm, \"total_time\"] = len(current_list_x)\n        results_table.loc[i_worm, \"raw_visits\"] = str(raw_durations)  # all visits of all patches\n        results_table.loc[i_worm, \"order_of_visits\"] = str(order_of_visits)  # patch order of visits\n        results_table.loc[i_worm, \"duration_sum\"] = duration_sum  # total duration of visits\n        results_table.loc[i_worm, \"nb_of_visits\"] = nb_of_visits  # total nb of visits\n        results_table.loc[i_worm, \"list_of_visited_patches\"] = str(list_of_visited_patches)  # index of patches visited\n        results_table.loc[i_worm, \"furthest_patch_distance\"] = furthest_patch_distance  # distance\n        results_table.loc[i_worm, \"total_transit_time\"] = total_transit_time\n        results_table.loc[i_worm, \"adjusted_raw_visits\"] = str(adjusted_raw_visits)\n        results_table.loc[i_worm, \"adjusted_duration_sum\"] = adjusted_duration_sum\n        results_table.loc[i_worm, \"adjusted_nb_of_visits\"] = adjusted_nb_of_visits\n\n    return results_table\n\n\ndef generate_and_save(path):\n    trajectories = fd.trajmat_to_dataframe(fd.path_finding_traj(path))  # run this to retrieve trajectories\n    trajectories.to_csv(path + \"trajectories.csv\")\n    results = patch_visits_multiple_traj(trajectories)\n    results.to_csv(path + \"results.csv\")\n    return 0\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/generate_results.py b/generate_results.py
--- a/generate_results.py	
+++ b/generate_results.py	
@@ -186,7 +186,7 @@
 
 def generate_and_save(path):
     trajectories = fd.trajmat_to_dataframe(fd.path_finding_traj(path))  # run this to retrieve trajectories
-    trajectories.to_csv(path + "trajectories.csv")
+    trajectories.to_csv(path + "old_trajectories.csv")
     results = patch_visits_multiple_traj(trajectories)
-    results.to_csv(path + "results.csv")
+    results.to_csv(path + "old_results.csv")
     return 0
